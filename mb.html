<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>IMAT Practice — Chemistry & Biology</title>
<style>
  :root{
    --bg:#f5f7fa;
    --fg:#101113;
    --card:#ffffff;
    --muted:#6b7280;
    --accent:#0a84ff;
    --accent-600:#066bd6;
    --ok:#0a8f3e;
    --bad:#d43f3a;
    --shadow:0 8px 30px rgba(16,17,19,0.06);
    --radius:12px;
    --btn-padding:12px 14px;
    --max-width:920px;
    --text-on-white: var(--fg);
    --btn-bg: var(--fg);
    --btn-color: #fff;
    --btn-secondary-bg: #fff;
    --btn-secondary-color: var(--fg);
    --btn-ghost-border: #e6e6e9;
    --muted-on-dark: #e6e7e9;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    font-family: Inter, -apple-system, system-ui, "Segoe UI", Roboto, Arial;
    background:var(--bg); color:var(--fg); margin:0; padding:20px; display:flex; justify-content:center;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }
  .app{width:100%;max-width:var(--max-width);}
  h1{font-size:1.45rem;margin:0 0 10px}
  h2{font-size:1.05rem;margin:0}
  .muted{color:var(--muted)}
  .small{font-size:.9rem;color:var(--muted)}
  .card{background:var(--card);border-radius:var(--radius);padding:16px;box-shadow:var(--shadow);margin-bottom:14px; color:inherit;}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .subjectTitle{font-weight:700;color:#fff;padding:8px;border-radius:8px;display:inline-block}
  button{
    background:var(--btn-bg); color:var(--btn-color); border:0; border-radius:10px; padding:var(--btn-padding); font-size:1rem;
    cursor:pointer; transition:transform .12s ease, box-shadow .12s ease, background .12s ease;
  }
  button:active{ transform:translateY(1px) }
  button.secondary{
    background:var(--btn-secondary-bg);
    color:var(--btn-secondary-color);
    border:1px solid var(--btn-ghost-border);
    box-shadow:none;
  }
  button.ghost{
    background:transparent;
    color:var(--fg);
    border:1px dashed var(--btn-ghost-border);
  }
  button[disabled]{ opacity:.55; cursor:not-allowed; transform:none; }
  button:focus, input:focus, select:focus, textarea:focus { outline:3px solid rgba(10,132,255,0.14); outline-offset:2px; }
  input[type="password"], input[type="text"]{ width:100%; padding:12px;border-radius:10px;border:1px solid #e6e6e9;font-size:1rem; color:inherit; background:#fff; }
  .quiz-progress-bar {
    position: fixed; left:50%; transform:translateX(-50%); bottom:18px; z-index:1200;
    background:var(--card); box-shadow:var(--shadow); border-radius:14px; padding:12px 18px; min-width:260px;
    display:flex; flex-direction:column; align-items:center; gap:8px;
  }
  .quiz-progress-bar[hidden]{ display:none !important; }
  .progress{ width:100%; height:10px; background:#f0f2f5; border-radius:999px; overflow:hidden; }
  .progress>i{ display:block; height:100%; width:0%; background:linear-gradient(90deg,var(--accent),var(--accent-600)); transition:width .28s ease; }
  .quiz-timer{ font-size:.95rem; color:var(--muted); }
  fieldset{
    border:1px solid #f0f2f5; padding:12px; border-radius:10px; margin:10px 0;
    background:linear-gradient(180deg,#fff,#fbfdff);
    color: var(--text-on-white);
  }
  fieldset legend{ font-weight:700; color: var(--text-on-white); }
  label.option{ display:flex; gap:12px; align-items:flex-start; padding:9px; border-radius:8px; cursor:pointer; transition:background .12s ease, transform .08s ease; color:var(--text-on-white); }
  label.option:hover{ background:#f7f9fc; transform:translateY(-1px) }
  label.option input[type="radio"]{ margin-top:3px; }
  .year{ color:var(--muted); font-size:.85rem; margin-top:6px; margin-bottom:8px; }
  .site-message{ position:fixed; left:50%; transform:translateX(-50%); top:22px; z-index:1300; min-width:280px; max-width:92%; }
  .notice{ display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; border-radius:12px; background:var(--card); box-shadow:var(--shadow); }
  .notice .msg{ flex:1 }
  .notice .actions{ display:flex; gap:8px; margin-left:8px; }
  .overlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:1400; background:rgba(6,10,15,0.28); backdrop-filter:blur(2px); }
  .loader{ width:88px; height:88px; border-radius:16px; background:var(--card); box-shadow:var(--shadow); display:flex; align-items:center; justify-content:center; flex-direction:column; gap:8px; padding:12px; }
  .spinner{ width:36px; height:36px; border-radius:50%; border:4px solid #e9eef8; border-top-color:var(--accent); animation:spin 1s linear infinite; }
  @keyframes spin{ to{ transform:rotate(360deg); } }
  .pill{ display:inline-block; padding:6px 10px; border-radius:999px; background:#fff; color:var(--text-on-white); box-shadow:0 6px 18px rgba(16,17,19,0.04); margin-right:8px; }
  .correct{ color:var(--ok) } .incorrect{ color:var(--bad) } .no-answer{ color:var(--muted) } .muted.small{ font-size:.86rem }
  @media (max-width:720px){
    body{ padding:14px } .card{ padding:12px } button{ padding:10px 12px }
    .quiz-progress-bar{
  right:8px; left:auto; bottom:8px; transform:none;
  min-width:auto; width:148px; padding:8px 10px;
}
.quiz-progress-bar .progress{ height:6px; }
.quiz-progress-bar .quiz-timer{ font-size:.78rem; }
}
  body.dark {
    --bg: #0b0b0d;
    --fg: #e6e7e9;
    --card: #0f1113;
    --muted: #bfc6cc;
    --accent: #0a84ff;
    --accent-600: #0860d0;
    --ok: #34b36a;
    --bad: #e0524b;
    --shadow: 0 10px 30px rgba(0,0,0,0.55);
    --radius: 12px;
    --btn-padding: 12px 14px;
    --max-width: 920px;
    --btn-bg: #ffffff;
    --btn-color: #0b0b0d;
    --btn-secondary-bg: var(--card);
    --btn-secondary-color: var(--fg);
    --btn-ghost-border: #2b2b2b;
    --text-on-white: #000000;
    --muted-on-dark: #cfd6db;
  }
  body.dark { background: var(--bg); color: var(--fg); }
  body.dark .card { background: var(--card); color: var(--fg); box-shadow: var(--shadow); }
  body.dark fieldset,
  body.dark .pill,
  body.dark input[type="text"],
  body.dark input[type="password"],
  body.dark .notice,
  body.dark .loader,
  body.dark .site-message,
  body.dark .progress {
    background: #ffffff;
    color: var(--text-on-white);
    border-color: #e6e6e9;
  }
  body.dark fieldset,
  body.dark fieldset * ,
  body.dark .pill,
  body.dark .pill *,
  body.dark input[type="text"],
  body.dark input[type="password"],
  body.dark .notice,
  body.dark .notice * ,
  body.dark .loader,
  body.dark .loader * ,
  body.dark .site-message,
  body.dark .site-message * {
    color: var(--text-on-white) !important;
  }
  body.dark button { background: var(--btn-bg); color: var(--btn-color); border: 0; }
  body.dark button.secondary { background: var(--btn-secondary-bg); color: var(--btn-secondary-color); border: 1px solid var(--btn-ghost-border); }
  body.dark input[type="text"], body.dark input[type="password"] { background: #fff; color: var(--text-on-white); border: 1px solid #e6e6e9; }
  body.dark .muted, body.dark .small, body.dark .year { color: var(--muted-on-dark); }
  body.dark .spinner { border-top-color: var(--accent); }
  body.dark .card fieldset, body.dark .card .pill, body.dark .card fieldset * { background: #fff; color: var(--text-on-white); }
  body.dark button:focus, body.dark input:focus, body.dark select:focus, body.dark textarea:focus {
    outline: 3px solid rgba(10,132,255,0.18);
    outline-offset: 2px;
  }
</style>
</head>
<body>
<div class="app" role="application" aria-label="IMAT Practice">

  <!-- site message / toast -->
  <div id="siteMessage" class="site-message" style="display:none;" aria-live="polite">
    <div class="notice">
      <div id="siteMessageText" class="msg"></div>
      <div id="siteMessageBtns" class="actions"></div>
    </div>
  </div>

  <!-- overlay -->
  <div id="overlay" class="overlay" style="display:none;">
    <div class="loader" role="status" aria-live="polite">
      <div class="spinner" aria-hidden="true"></div>
      <div id="overlayText" class="muted small">Caricamento...</div>
    </div>
  </div>

  <!-- quiz progress bar -->
  <div id="quizProgressBar" class="quiz-progress-bar" hidden>
    <div class="progress"><i id="progBar" style="width:0%"></i></div>
    <div class="quiz-timer" id="quizTimer">Tempo: 0:00</div>
  </div>

  <!-- LOGIN -->
  <div id="login" class="card screen active" data-screen="login">
    <h1>IMAT Practice — Login</h1>
    <p class="muted small">Inserisci la passkey per accedere.</p>
    <input id="passkey" type="password" placeholder="Passkey (0000)" aria-label="Passkey" />
    <div style="margin-top:12px" class="row">
      <button id="loginBtn" style="flex:1">Entra</button>
    </div>
    <p class="muted small" style="margin-top:10px;">0000 = Guest</p>
  </div>

  <!-- HOME -->
  <div id="home" class="screen" style="display:none;">
    <div class="topbar card" style="align-items:center;">
      <div>
        <h1 id="welcomeTitle">IMAT Practice</h1>
        <div class="muted small" id="welcomeSub">Seleziona materia e modalità</div>
      </div>
      <div class="row">
        <button class="secondary" id="toggleThemeBtn" title="Tema">🌙</button>
        <button class="secondary" id="logoutBtn">Logout</button>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
        <div>
          <span class="subjectTitle" style="background:linear-gradient(90deg,var(--accent),var(--accent-600))">Chimica</span>
          <div class="muted small" style="margin-top:6px">Domande estratte da IMAT / esercizi</div>
        </div>
        <div class="row">
          <button id="startChemBtn">Start Chemistry Quiz</button>
          <button id="chemTrainingBtn" class="secondary">Training Mode</button>
          <button id="historyChemBtn" class="ghost">History</button>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
        <div>
          <span class="subjectTitle" style="background:linear-gradient(90deg,#2bbf7e,#19a86c)">Biologia</span>
          <div class="muted small" style="margin-top:6px">Domande estratte da IMAT / esercizi</div>
        </div>
        <div class="row">
          <button id="startBioBtn">Start Biology Quiz</button>
          <button id="bioTrainingBtn" class="secondary">Training Mode</button>
          <button id="historyBioBtn" class="ghost">History</button>
        </div>
      </div>
    </div>
  </div>

  <!-- QUIZ -->
  <div id="quiz" class="screen" style="display:none;"></div>

  <!-- REVIEW -->
  <div id="review" class="screen" style="display:none;"></div>

  <!-- RESULT -->
  <div id="result" class="screen" style="display:none;"></div>

  <!-- HISTORY -->
  <div id="history" class="screen" style="display:none;"></div>

  <!-- TRAINING -->
  <div id="training" class="screen" style="display:none;"></div>

</div>

<script>
/* =========================
   LOGICA RISCRITTA CON:
   - NO doppi nello stesso quiz
   - Ciclo "usa tutte le domande prima di ripetere" per ogni utente/materia
   - Statistica di completamento nella History
   Mantengo tutte le altre logiche esistenti (score, qstats, training ecc.)
   ========================= */

/* --- constants / state --- */
const USERS = {"2010":"Chiara","2111":"Ale","2405":"Tony","0000":"Guests"};
let currentUser = null;

let chemistryQuestions = null, chemistryQuestionsLoaded=false, chemistryLoading=false, chemistryCallbacks=[];
let biologyQuestions = null, biologyQuestionsLoaded=false, biologyLoading=false, biologyCallbacks=[];

let activeSubject = null, activePool = null, shuffledQuestions = [];
const RECENT_CACHE_SIZE = 30; // mantiene ancora una storia breve locale aggiuntiva
let lastAskedPerUser = {}; // session-only cache: { userKey: [subject::questionText,...] }

/* stopwatch/progress */
let quizStartTime = null, quizTimerInterval = null, quizElapsedSeconds = 0;

/* helpers localStorage */
function lsGet(key, def){ try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : def; }catch(e){ return def; } }
function lsSet(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); }catch(e){} }

/* --- Persistenza delle domande "usate" per utente/materia ---
   Struttura in localStorage 'imat_used_questions':
   { "<user>": { "Chemistry": ["Domanda 1", "Domanda 2", ...], "Biology": [...] } }
*/
function loadUsedQuestionsStore(){ return lsGet('imat_used_questions', {}); }
function saveUsedQuestionsStore(obj){ lsSet('imat_used_questions', obj); }
function getUsedSetFor(user, subject){
  const store = loadUsedQuestionsStore();
  if(!store[user]) return new Set();
  const arr = store[user][subject] || [];
  return new Set(arr);
}
function addUsedQuestions(user, subject, questionsArray){
  const store = loadUsedQuestionsStore();
  if(!store[user]) store[user] = {};
  if(!store[user][subject]) store[user][subject] = [];
  const set = new Set(store[user][subject]);
  questionsArray.forEach(qtxt => set.add(qtxt));
  store[user][subject] = Array.from(set);
  saveUsedQuestionsStore(store);
}
function resetUsedQuestionsFor(user, subject){
  const store = loadUsedQuestionsStore();
  if(!store[user]) store[user] = {};
  store[user][subject] = [];
  saveUsedQuestionsStore(store);
}

/* qstats helpers (mantieni la logica originale) */
function _qKey(subject, question){ return `${subject || 'Unknown'}::${question}`; }
function loadQStats(){ return lsGet('imat_qstats', {}); }
function saveQStats(o){ lsSet('imat_qstats', o); }
function incQAsked(subject, q){ const s=loadQStats(); const k=_qKey(subject,q); s[k]=s[k]||{asked:0,wrong:0}; s[k].asked++; saveQStats(s); }
function incQWrong(subject, q){ const s=loadQStats(); const k=_qKey(subject,q); s[k]=s[k]||{asked:0,wrong:0}; s[k].wrong++; saveQStats(s); }
function resetQWrong(subject, q){ const s=loadQStats(); const k=_qKey(subject,q); if(s[k]){ s[k].wrong=0; saveQStats(s);} }
function getQStatsFor(subject, q){ const s=loadQStats(); const k=_qKey(subject,q); return s[k]||{asked:0,wrong:0}; }

/* UI helpers */
function showScreen(id){
  document.querySelectorAll('.screen').forEach(el => el.style.display = 'none');
  const el = document.getElementById(id);
  if(el) el.style.display = 'block';
  if(id === 'history') renderHistory();
}
function toast(html, buttons = []){
  const wrap = document.getElementById('siteMessage');
  document.getElementById('siteMessageText').innerHTML = html;
  const btnWrap = document.getElementById('siteMessageBtns'); btnWrap.innerHTML = '';
  buttons.forEach(b => {
    const btn = document.createElement('button');
    btn.textContent = b.label;
    btn.className = b.secondary ? 'secondary' : '';
    btn.onclick = () => { wrap.style.display='none'; if(b.onClick) b.onClick(); };
    btnWrap.appendChild(btn);
  });
  wrap.style.display = 'block';
}
function showOverlay(text = 'Caricamento...'){ const ov = document.getElementById('overlay'); document.getElementById('overlayText').textContent = text; ov.style.display = 'flex'; document.body.setAttribute('aria-busy','true'); }
function hideOverlay(){ document.getElementById('overlay').style.display = 'none'; document.body.removeAttribute('aria-busy'); }

/* utilities */
function shuffleArray(arr){ const a = arr.slice(); for(let i=a.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

/* --- Scelta delle domande per quiz:
   Requisiti:
   1) Nessuna domanda doppia nello stesso quiz.
   2) Per utente+materia non riproporre domande già usate fino a che non sono state usate tutte.
   Implementazione:
   - Identifichiamo una "chiave" della domanda: preferiamo `q.question` (testo) come identificatore stabile.
   - Prendiamo le domande disponibili = pool.filter not in usedSet.
   - Se disponibili < n: prendiamo le disponibili rimaste, poi resettiamo il used-set (per quella materia e utente) e prendiamo il resto delle domande necessarie dalla totalità, evitando duplicati nello stesso quiz.
*/
function pickQuestions(pool, n){
  // pool: array di oggetti domanda, n: numero richiesto
  // rimuoviamo eventuali duplicati testuali in pool (garantiamo un pool "per testo")
  const uniqueMap = new Map();
  pool.forEach(q => { uniqueMap.set((q.question || '').trim(), q); });
  const uniquePool = Array.from(uniqueMap.values());

  const usedSet = getUsedSetFor(currentUser, activeSubject);
  // filter by not used
  let available = uniquePool.filter(q => !usedSet.has(q.question));
  // if available insufficient, we will take all available, then reset used-set and take remaining from full pool excluding ones already chosen for this quiz
  const chosen = [];
  const toPick = Math.min(n, uniquePool.length);
  // Step 1: take from available up to toPick
  while(chosen.length < toPick && available.length > 0){
    const idx = Math.floor(Math.random() * available.length);
    chosen.push(available.splice(idx,1)[0]);
  }
  if(chosen.length === toPick){
    return chosen;
  }
  // Step 2: if we haven't reached toPick, it means available exhausted -> reset used-set (user has now completed all)
  resetUsedQuestionsFor(currentUser, activeSubject);
  // Recompute unique pool (same as above) and exclude any already selected in 'chosen' (to avoid duplicates within the quiz)
  const remainingCandidates = uniquePool.filter(q => !chosen.some(c => c.question === q.question));
  // Shuffle and select remaining
  const shuffled = shuffleArray(remainingCandidates);
  for(let i=0; i<shuffled.length && chosen.length < toPick; i++){
    chosen.push(shuffled[i]);
  }
  // If pool smaller than requested, chosen may be < toPick; that's fine.
  return chosen;
}

/* stopwatch */
function startStopwatch(){
  quizStartTime = Date.now();
  const el = document.getElementById('quizTimer');
  function upd(){
    const s = Math.floor((Date.now() - quizStartTime)/1000);
    const mm = Math.floor(s/60), ss = s%60;
    el.textContent = 'Tempo: ' + mm + ':' + (ss<10?('0'+ss):ss);
  }
  upd();
  quizTimerInterval = setInterval(upd, 500);
}
function stopStopwatch(){
  if(quizTimerInterval) clearInterval(quizTimerInterval);
  quizTimerInterval = null;
  if(quizStartTime) quizElapsedSeconds = Math.floor((Date.now() - quizStartTime)/1000);
  else quizElapsedSeconds = 0;
}

/* topic suggestion (mantengo) */
const topicKeywordsChem = [
  {k:['ph','acid','base','hcl','h2so4','hno3'],'topic':'Acidi e Basi'},
  {k:['titr','naoh','molar','concentra','neutraliz'],'topic':'Titolazioni e concentrazioni'},
  {k:['dipole','polar','intermolecular','hydrogen'],'topic':'Struttura molecolare e legami'},
  {k:['stoichiom','mol','avogadro','moles','massa'],'topic':'Stechiometria e moli'},
  {k:['redox','oxid','reduc'],'topic':'Reazioni redox'},
  {k:['organic','ester','alcohol','ketone'],'topic':'Chimica organica'}
];
const topicKeywordsBio = [
  {k:['mitochondria','atp','respiration'],'topic':'Metabolismo e ATP'},
  {k:['dna','rna','replication','transcription','translation'],'topic':'Genetica e sintesi proteica'},
  {k:['ribosome','ribosomal'],'topic':'Ribosomi'},
  {k:['membrane','transport','carrier'],'topic':'Membrane e trasporto'},
  {k:['allele','dominant','recessive','mutation'],'topic':'Ereditarietà e mutazioni'},
  {k:['cytoskeleton','microtubules','centriole'],'topic':'Citroscheletro'}
];
function suggestTopicFromWrong(subject, details){
  const keywords = subject === 'Biology' ? topicKeywordsBio : topicKeywordsChem;
  const counts = {};
  details.forEach(d => {
    if(d.correct) return;
    const qtext = (d.q || '').toLowerCase();
    keywords.forEach(t => {
      t.k.forEach(kw => { if(qtext.indexOf(kw) !== -1) counts[t.topic] = (counts[t.topic] || 0) + 1; });
    });
  });
  let best = null, bestC = 0;
  for(const k in counts){ if(counts[k] > bestC){ bestC = counts[k]; best = k; } }
  return best || 'Ripassa i concetti fondamentali.';
}

/* JSON loading (mantengo la logica di caricamento con callback queue) */
function loadChemistryQuestions(cb){
  if(chemistryQuestionsLoaded){ if(cb) cb(null); return; }
  if(cb) chemistryCallbacks.push(cb);
  if(chemistryLoading) return;
  chemistryLoading = true;
  showOverlay('Caricamento domande di chimica...');
  fetch('./chemistry-questions.json').then(r => {
    if(!r.ok) throw new Error('HTTP ' + r.status);
    return r.json();
  }).then(data => {
    chemistryQuestions = data;
    chemistryQuestionsLoaded = true;
    chemistryLoading = false;
    chemistryCallbacks.forEach(f => f && f(null)); chemistryCallbacks = [];
  }).catch(err => {
    chemistryLoading = false;
    chemistryCallbacks.forEach(f => f && f(err)); chemistryCallbacks = [];
    toast('Errore nel caricamento delle domande di chimica.<br><span class="small">'+(err && err.message? err.message : '')+'</span>', [{label:'OK', secondary:true}]);
  }).finally(()=> hideOverlay());
}
function loadBiologyQuestions(cb){
  if(biologyQuestionsLoaded){ if(cb) cb(null); return; }
  if(cb) biologyCallbacks.push(cb);
  if(biologyLoading) return;
  biologyLoading = true;
  showOverlay('Caricamento domande di biologia...');
  fetch('./biology-questions.json').then(r => {
    if(!r.ok) throw new Error('HTTP ' + r.status);
    return r.json();
  }).then(data => {
    biologyQuestions = data;
    biologyQuestionsLoaded = true;
    biologyLoading = false;
    biologyCallbacks.forEach(f => f && f(null)); biologyCallbacks = [];
  }).catch(err => {
    biologyLoading = false;
    biologyCallbacks.forEach(f => f && f(err)); biologyCallbacks = [];
    toast('Errore nel caricamento delle domande di biologia.<br><span class="small">'+(err && err.message? err.message : '')+'</span>', [{label:'OK', secondary:true}]);
  }).finally(()=> hideOverlay());
}

/* AUTH */
function login(){
  const key = (document.getElementById('passkey').value || '').trim();
  if(USERS[key]){
    currentUser = key;
    document.getElementById('welcomeTitle').textContent = 'IMAT Practice — ' + USERS[key];
    document.getElementById('welcomeSub').textContent = 'Seleziona materia e modalità';
    showScreen('home');
  } else {
    toast('Passkey non valida.', [{label:'OK', secondary:true}]);
  }
}
function logout(){ currentUser = null; document.getElementById('passkey').value=''; showScreen('login'); }

/* --- Quiz / Training / History / ecc. --- */

function startGenericQuizFor(subject, pool){
  if(!currentUser){ showScreen('login'); return; }
  activeSubject = subject;
  activePool = pool;

  // pick questions using la nuova logica che evita duplicati e gestisce il ciclo "tutte prima di ripetere"
  const n = Math.min(15, activePool.length);
  shuffledQuestions = pickQuestions(activePool, n);

  // registra come "usate" le domande scelte (salva i testi)
  addUsedQuestions(currentUser, activeSubject, shuffledQuestions.map(q => q.question));

  // aggiorna also lastAskedPerUser session cache (per evitare ripetizioni immediate)
  if(!lastAskedPerUser[currentUser]) lastAskedPerUser[currentUser] = [];
  lastAskedPerUser[currentUser] = lastAskedPerUser[currentUser].concat(shuffledQuestions.map(q => activeSubject + '::' + q.question));
  if(lastAskedPerUser[currentUser].length > RECENT_CACHE_SIZE) lastAskedPerUser[currentUser] = lastAskedPerUser[currentUser].slice(-RECENT_CACHE_SIZE);

  // build UI (mantengo la struttura originale)
  let html = `<div class="card"><div class="row" style="justify-content:space-between;align-items:center"><h2>Quiz — ${activeSubject}</h2><div class="muted small">Domande: ${shuffledQuestions.length}</div></div>`;
  shuffledQuestions.forEach((q,i) => {
    const idxs = shuffleArray(q.options.map((_,k) => k));
    html += `<fieldset><legend>Q${i+1}: ${q.question}</legend>`;
    html += `<div class="year">Anno: ${q.year || '—'}</div>`;
    idxs.forEach(k => {
      html += `<label class="option"><input type="radio" name="q${i}" value="${k}"> <div>${q.options[k]}</div></label>`;
    });
    html += `</fieldset>`;
  });
  html += `<div class="row" style="margin-top:8px"><button id="submitBtn">Termina Quiz</button><button class="secondary" id="cancelQuizBtn">Annulla</button></div></div>`;
  document.getElementById('quiz').innerHTML = html;
  document.querySelectorAll('#quiz input[type=radio]').forEach(inp => inp.addEventListener('change', updateProgress));
  document.getElementById('submitBtn').onclick = submitQuiz;
  document.getElementById('cancelQuizBtn').onclick = () => showScreen('home');
  updateProgress();
  showScreen('quiz');
  document.getElementById('quizProgressBar').hidden = false;
  stopStopwatch(); startStopwatch();
}

function updateProgress(){
  const total = shuffledQuestions.length;
  let answered = 0;
  for(let i=0;i<total;i++){ if(document.querySelector('input[name="q'+i+'"]:checked')) answered++; }
  const pct = Math.round((answered/total)*100);
  const bar = document.getElementById('progBar'); if(bar) bar.style.width = pct + '%';
}

function submitQuiz(){
  stopStopwatch();
  document.getElementById('quizProgressBar').hidden = true;

  let score=0, correctCount=0, wrong=0;
  const totalQuestions = shuffledQuestions.length;
  const details = [];

  for(let i=0;i<totalQuestions;i++){
    const q = shuffledQuestions[i];
    const sel = document.querySelector('input[name="q'+i+'"]:checked');
    const idx = sel ? parseInt(sel.value,10) : null;
    const ok = (idx === q.correct);
    if(idx !== null){
      details.push({ q: q.question, chosen: idx, correct: ok, year: q.year });
      incQAsked(activeSubject, q.question); // solo per le domande effettivamente risposte
      if(!ok) incQWrong(activeSubject, q.question);
      if(ok){ score += 1.5; correctCount++; } else { score -= 0.4; wrong++; }
    } else {
      details.push({ q: q.question, chosen: null, correct: null, year: q.year });
    }
  }

  const answered = details.filter(d => d.chosen !== null).length;
  const notAnswered = totalQuestions - answered;

  // Salvataggio risultato (mantengo stessa struttura, nota: total = numero di risposte date)
  const all = lsGet('imat_results', {});
  if(!all[currentUser]) all[currentUser] = [];
  all[currentUser].push({
    score: score,
    wrong: wrong,
    total: answered,
    numQuestions: totalQuestions,
    correct: correctCount,
    date: new Date().toLocaleString(),
    details: details,
    subject: activeSubject,
    training: false,
    elapsed: quizElapsedSeconds
  });
  lsSet('imat_results', all);

  // reset wrong per domande corrette
  details.forEach(d => { if(d.correct) resetQWrong(activeSubject, d.q); });

  const pctC = answered ? ((correctCount/answered)*100).toFixed(1) : '0.0';
  const pctW = answered ? (((answered-correctCount)/answered)*100).toFixed(1) : '0.0';
  const suggestion = suggestTopicFromWrong(activeSubject, details);
  const timeStr = formatElapsed(quizElapsedSeconds);

  let rev = `<div class="card"><h2>Revisione — ${activeSubject}</h2>`;
  rev += `<div style="margin-top:8px"><span class="pill">Corrette: ${correctCount}/${answered} (${pctC}%)</span><span class="pill">Sbagliate: ${wrong} (${pctW}%)</span><span class="pill">Non risposte: ${notAnswered}</span><span class="pill">Tempo: ${timeStr}</span></div>`;
  rev += `<div class="muted small" style="margin-top:8px">Consiglio: <strong>${suggestion}</strong></div>`;
  rev += `<div class="row" style="margin-top:12px"><button id="toResultBtn">Vai al riepilogo</button><button class="secondary" id="retryBtn">Riprova</button></div></div>`;
  document.getElementById('review').innerHTML = rev;
  document.getElementById('toResultBtn').onclick = () => renderResult(details, score, quizElapsedSeconds);
  document.getElementById('retryBtn').onclick = () => startGenericQuizFor(activeSubject, activePool);
  showScreen('review');
}

function formatElapsed(sec){ const mm = Math.floor(sec/60), ss = sec%60; return mm + ':' + (ss<10?('0'+ss):ss); }

function renderResult(details, score, elapsed){
  const resultDiv = document.getElementById('result');
  const answered = details.filter(d => d.chosen !== null).length;
  const correctCount = details.filter(d => d.correct).length;
  const total = details.length;
  const notAnswered = total - answered;
  const percent = answered ? ((correctCount/answered)*100).toFixed(1) : '0.0';
  const timeStr = formatElapsed(typeof elapsed === "number" ? elapsed : quizElapsedSeconds);

  let html = `<div class="card"><h2>Riepilogo Finale — ${activeSubject}</h2>`;
  html += `<div style="margin-top:8px"><strong>Punteggio:</strong> ${score.toFixed(2)} • ${percent}% (solo risposte date)</div>`;
  html += `<div style="margin-top:8px"><span class="pill">Corrette: ${correctCount}</span><span class="pill">Sbagliate: ${answered-correctCount}</span><span class="pill">Non risposte: ${notAnswered}</span><span class="pill">Tempo: ${timeStr}</span></div>`;
  html += `</div>`;

  details.forEach((d,i) => {
    const q = shuffledQuestions[i];
    html += `<fieldset><legend>Domanda ${i+1}</legend><div class="year">Anno: ${d.year || '—'}</div><p><strong>${q.question}</strong></p><form style="margin-bottom:0.7em;">`;
    q.options.forEach((opt, idx) => {
      const checked = (d.chosen === idx) ? 'checked' : '';
      const disabled = 'disabled';
      let style = '';
      if(idx === q.correct) style = 'font-weight:bold;color:var(--ok);';
      else if(d.chosen === idx && d.chosen !== q.correct) style = 'font-weight:bold;color:var(--bad);';
      html += `<label style="display:flex;align-items:center;gap:8px;${style}"><input type="radio" name="q${i}" value="${idx}" ${checked} ${disabled}>${opt}</label>`;
    });
    html += `</form>`;
    if(d.chosen === null) html += `<p class="no-answer">➖ Nessuna risposta data</p>`;
    else html += `<p>${ d.correct ? '<span class="correct">✔ Corretta</span>' : '<span class="incorrect">✘ Sbagliata</span>' }</p>`;
    if(q.explanation) html += `<p class="muted small">Spiegazione: ${q.explanation}</p>`;
    html += `</fieldset>`;
  });

  html += `<div class="row" style="margin-top:10px"><button id="repeatBtn">Ripeti Quiz</button><button class="secondary" id="homeBtn">Home</button></div>`;
  resultDiv.innerHTML = html;
  document.getElementById('repeatBtn').onclick = () => startGenericQuizFor(activeSubject, activePool);
  document.getElementById('homeBtn').onclick = () => showScreen('home');
  showScreen('result');
}

/* Training logic (rimane invariata la logica originale; non applico ciclo "usa tutte" al training) */
function pickTrainingQuestionFrom(pool, subject){
  const poolCopy = pool.slice();
  const weights = [], totalW = poolCopy.reduce((acc,q) => {
    const s = getQStatsFor(subject,q.question); const w = 1 + (s.wrong || 0); weights.push(w); return acc + w;
  }, 0);
  let r = Math.random() * totalW, cum = 0;
  for(let i=0;i<poolCopy.length;i++){ cum += weights[i]; if(r <= cum) return poolCopy[i]; }
  return poolCopy[0];
}
function startGenericTrainingFor(subject, pool){
  if(!currentUser){ showScreen('login'); return; }
  activeSubject = subject; activePool = pool;
  showTrainingQuestion();
}
function showTrainingQuestion(){
  const q = pickTrainingQuestionFrom(activePool, activeSubject);
  const el = document.getElementById('training');
  const s = getQStatsFor(activeSubject, q.question);
  let html = `<div class="card"><h2>Modalità Allenamento — ${activeSubject}</h2>`;
  html += `<fieldset><legend>${q.question}</legend><div class="year">Anno: ${q.year || '—'} • Sbagliata: ${s.wrong || 0} • Proposta: ${s.asked || 0}</div>`;
  q.options.forEach((opt,i) => html += `<label class="option"><input type="radio" name="trainAns" value="${i}"><div>${opt}</div></label>`);
  html += `</fieldset>`;
  html += `<div class="row"><button id="checkBtn">Conferma</button><button id="nextBtn" disabled>Avanti</button><button class="secondary" id="homeBtn2">Home</button></div>`;
  html += `<div id="trainFeedback" style="margin-top:10px"></div></div>`;
  el.innerHTML = html; showScreen('training');
  document.getElementById('homeBtn2').onclick = () => showScreen('home');

  document.getElementById('checkBtn').onclick = () => {
    const ans = document.querySelector('input[name="trainAns"]:checked');
    if(!ans){ toast('Seleziona una risposta.', [{label:'OK', secondary:true}]); return; }
    const idx = parseInt(ans.value,10), correct = (idx === q.correct);
    incQAsked(activeSubject, q.question);
    if(!correct) incQWrong(activeSubject, q.question);

    const all = lsGet('imat_results', {});
    if(!all[currentUser]) all[currentUser] = [];
    const score = correct ? 1.5 : -0.4;
    const wrong = correct ? 0 : 1;
    const details = [{ q: q.question, chosen: idx, correct: correct, year: q.year }];
    all[currentUser].push({ score: score, wrong: wrong, date: new Date().toLocaleString(), training:true, total:1, correct: correct?1:0, details: details, subject: activeSubject });
    lsSet('imat_results', all);

    if(correct) resetQWrong(activeSubject, q.question);

    const fb = document.getElementById('trainFeedback');
    if(correct) fb.innerHTML = `<p class="correct">✔ Corretto!</p><p class="muted small">${q.explanation || ''}</p>`;
    else fb.innerHTML = `<p class="incorrect">✘ Sbagliato.</p><p>Risposta corretta: ${q.options[q.correct]}</p><p class="muted small">${q.explanation || ''}</p>`;

    document.getElementById('checkBtn').disabled = true;
    const next = document.getElementById('nextBtn'); next.disabled = false;
    next.onclick = () => showTrainingQuestion();
  };
}

/* History (AGGIUNTA: statistica completamento delle domande per materia) */
function renderHistory(){
  if(!currentUser){ showScreen('login'); return; }
  const wrap = document.getElementById('history');

  // Assicuriamoci di avere i pool caricati per poter mostrare la statistica di completamento.
  function proceedRender(){
    const all = lsGet('imat_results', {});
    const res = all[currentUser] || [];
    let html = `<div class="card"><h2>History — ${USERS[currentUser] || ''}</h2>`;

    function renderSubjectBlock(subject, pool, poolLoaded){
      html += `<div style="margin-top:12px"><h3>${subject}</h3>`;
      const arr = res.filter(r => r.subject === subject);
      if(arr.length === 0) html += `<p class="muted">Nessun tentativo registrato per ${subject}.</p></div>`;
      else {
        let aggC=0, aggT=0; arr.forEach(r => { aggC += (r.correct || 0); aggT += (r.total || 0); });
        const pC = aggT ? ((aggC/aggT)*100).toFixed(1) : '0.0';
        const pW = aggT ? (((aggT-aggC)/aggT)*100).toFixed(1) : '0.0';
        html += `<div style="margin-top:8px"><span class="pill">Totale risposte: ${aggT}</span><span class="pill">Corrette: ${aggC} (${pC}%)</span><span class="pill">Sbagliate: ${aggT-aggC} (${pW}%)</span></div>`;
        html += `<div style="margin-top:10px">`;
        arr.forEach(r => {
          const ip = r.total ? (((r.correct||0)/r.total)*100).toFixed(1) : '0.0';
          const tag = r.training ? ' (Allenamento)' : ' (Quiz)';
          html += `<p>📅 ${r.date} → Score: ${typeof r.score === 'number' ? r.score.toFixed(2) : r.score} | %: ${ip} | Risposte non date: ${ (r.numQuestions || r.total) - (r.total || 0) }${tag}</p>`;
        });
        html += `</div>`;
      }

      // Statistica completamento delle domande (usa store 'imat_used_questions' per l'utente)
      const usedStore = loadUsedQuestionsStore();
      const usedArr = (usedStore[currentUser] && usedStore[currentUser][subject]) ? usedStore[currentUser][subject] : [];
      const usedCount = usedArr.length;
      let poolSizeText = '—';
      if(poolLoaded && Array.isArray(pool)) poolSizeText = pool.length;
      html += `<div style="margin-top:10px"><strong>Completamento pool:</strong> ${usedCount} / ${poolSizeText}`;
      if(poolLoaded && pool.length > 0){
        const pct = ((usedCount / pool.length) * 100).toFixed(1);
        html += ` (${pct}%)`;
      } else {
        html += ` <span class="muted small"> (carica le domande per vedere la percentuale)</span>`;
      }
      html += `</div>`;

      // Mostra domande più sbagliate (mantengo la costruzione)
      const wrongCount = {}, correctSet = {};
      arr.forEach(a => (a.details||[]).forEach(d => { if(d.correct) correctSet[d.q] = true; }));
      arr.forEach(a => (a.details||[]).forEach(d => { if(!d.correct && !correctSet[d.q]) wrongCount[d.q] = (wrongCount[d.q]||0) + 1; }));
      const list = Object.keys(wrongCount).map(k => ({q:k,count:wrongCount[k]})).sort((a,b)=>b.count-a.count);
      html += `<h4 style="margin-top:10px">Domande più sbagliate (${subject})</h4>`;
      if(list.length === 0) html += `<p class="muted">Nessuna domanda ricorrente sbagliata al momento.</p>`;
      else { html += '<ol>'; list.slice(0,8).forEach(it => html += `<li>${it.q} — sbagliata ${it.count} volte</li>`); html += '</ol>'; }

      html += `<div style="margin-top:10px"><button onclick="confirmClearSubject('${subject}')">Elimina dati solo di ${subject}</button></div>`;
      html += `</div>`;
    }

    renderSubjectBlock('Chemistry', chemistryQuestions, chemistryQuestionsLoaded);
    renderSubjectBlock('Biology', biologyQuestions, biologyQuestionsLoaded);

    html += `<div style="margin-top:12px" class="row"><button class="secondary" onclick="showScreen('home')">Home</button><button id="clearAllBtn">Elimina tutti i risultati</button></div></div>`;
    wrap.innerHTML = html;

    const clearAllBtn = document.getElementById('clearAllBtn');
    if(clearAllBtn) clearAllBtn.onclick = () => showClearConfirmationInHistoryAll();
  }

  // se i pool non sono caricati, carichiamoli prima di mostrare le percentuali
  const needsChem = !chemistryQuestionsLoaded;
  const needsBio = !biologyQuestionsLoaded;
  if(needsChem || needsBio){
    showOverlay('Caricamento domande per statistiche...');
    const tasks = [];
    if(needsChem) tasks.push(new Promise((res)=> loadChemistryQuestions(err => res(err))));
    if(needsBio) tasks.push(new Promise((res)=> loadBiologyQuestions(err => res(err))));
    Promise.all(tasks).then(() => { hideOverlay(); proceedRender(); }).catch(()=>{ hideOverlay(); proceedRender(); });
  } else {
    proceedRender();
  }
}

function confirmClearSubject(subject){
  toast(`<div>Vuoi davvero eliminare tutti i risultati di <strong>${subject}</strong>? Operazione irreversibile.</div>`, [
    { label:'Conferma', onClick: () => {
      const all = lsGet('imat_results', {});
      if(all[currentUser]) all[currentUser] = all[currentUser].filter(r => r.subject !== subject);
      lsSet('imat_results', all);
      const qs = loadQStats(); let changed=false;
      Object.keys(qs).forEach(k => { if(k.indexOf(subject + '::') === 0){ delete qs[k]; changed=true; } });
      if(changed) saveQStats(qs);
      // reset used questions for that subject as well
      resetUsedQuestionsFor(currentUser, subject);
      showScreen('history');
    }},
    { label:'Annulla', secondary:true }
  ]);
}
function showClearConfirmationInHistoryAll(){
  toast('Vuoi davvero eliminare tutti i risultati per questo utente? Operazione irreversibile.', [
    { label:'Conferma', onClick: () => { localStorage.removeItem('imat_results'); localStorage.removeItem('imat_qstats'); localStorage.removeItem('imat_used_questions'); showScreen('history'); } },
    { label:'Annulla', secondary:true }
  ]);
}

/* Wiring buttons */
document.getElementById('loginBtn').onclick = login;
document.getElementById('logoutBtn').onclick = logout;
document.getElementById('passkey').addEventListener('keyup', e => { if((e.key && e.key.toLowerCase()==='enter') || e.keyCode===13) login(); });

/* theme toggle */
(function(){
  const btn = document.getElementById('toggleThemeBtn');
  function apply(){ const on = localStorage.getItem('darkmode') === '1'; document.body.classList.toggle('dark', on); btn.textContent = on ? '☀️' : '🌙'; }
  btn.addEventListener('click', () => { const on = localStorage.getItem('darkmode') === '1'; localStorage.setItem('darkmode', on ? '0' : '1'); apply(); });
  apply();
})();

/* Chemistry buttons */
document.getElementById('startChemBtn').onclick = function(){
  if(chemistryQuestionsLoaded) startGenericQuizFor('Chemistry', chemistryQuestions);
  else { toast('Caricamento domande di chimica...', []); loadChemistryQuestions(function(err){ document.getElementById('siteMessage').style.display='none'; if(!err) startGenericQuizFor('Chemistry', chemistryQuestions); else toast('Errore nel caricamento delle domande di chimica.', [{label:'OK', secondary:true}]); }); }
};
document.getElementById('chemTrainingBtn').onclick = function(){
  if(chemistryQuestionsLoaded) startGenericTrainingFor('Chemistry', chemistryQuestions);
  else { toast('Caricamento domande di chimica...', []); loadChemistryQuestions(function(err){ document.getElementById('siteMessage').style.display='none'; if(!err) startGenericTrainingFor('Chemistry', chemistryQuestions); else toast('Errore nel caricamento delle domande di chimica.', [{label:'OK', secondary:true}]); }); }
};
document.getElementById('historyChemBtn').onclick = function(){ 
  if(chemistryQuestionsLoaded) showScreen('history'); 
  else { toast('Caricamento domande di chimica...', []); loadChemistryQuestions(() => { document.getElementById('siteMessage').style.display='none'; showScreen('history'); }); } 
};

/* Biology buttons */
document.getElementById('startBioBtn').onclick = function(){
  if(biologyQuestionsLoaded) startGenericQuizFor('Biology', biologyQuestions);
  else { toast('Caricamento domande di biologia...', []); loadBiologyQuestions(function(err){ document.getElementById('siteMessage').style.display='none'; if(!err) startGenericQuizFor('Biology', biologyQuestions); else toast('Errore nel caricamento delle domande di biologia.', [{label:'OK', secondary:true}]); }); }
};
document.getElementById('bioTrainingBtn').onclick = function(){
  if(biologyQuestionsLoaded) startGenericTrainingFor('Biology', biologyQuestions);
  else { toast('Caricamento domande di biologia...', []); loadBiologyQuestions(function(err){ document.getElementById('siteMessage').style.display='none'; if(!err) startGenericTrainingFor('Biology', biologyQuestions); else toast('Errore nel caricamento delle domande di biologia.', [{label:'OK', secondary:true}]); }); }
};
document.getElementById('historyBioBtn').onclick = function(){ 
  if(biologyQuestionsLoaded) showScreen('history'); 
  else { toast('Caricamento domande di biologia...', []); loadBiologyQuestions(() => { document.getElementById('siteMessage').style.display='none'; showScreen('history'); }); } 
};

hideOverlay();
/* End */
</script>
</body>
</html>
